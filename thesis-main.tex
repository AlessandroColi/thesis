\documentclass[12pt,a4paper,openright,twoside]{book}
\usepackage[italian,english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{disi-thesis}
\usepackage{code-lstlistings}
\usepackage{notes}
\usepackage{shortcuts}
\usepackage{acronym}

\school{\unibo}
\programme{Corso di Laurea in Ingegneria e Scienze Informatiche}
\title{Kotlin Multiplatform e PulvReAKt: analisi e prototipazione di applicazioni IoT eterogenee}
\author{Coli Alessandro}
\date{\today}
\subject{Programmazione ad Oggetti}
\supervisor{Prof. Viroli Mirko}
\cosupervisor{Dott. Farabegoli Nicolas}
\session{I}
\academicyear{2023-2024}

% Definition of acronyms
\acrodef{IoT}{Internet of Thing}
\acrodef{JVM}{Java Virtual Machine}
\acrodef{JS}{JavaScript}
\acrodef{MQTT}{Message Queuing Telemetry Transport}
\acrodef{QoS}{Quality of Service}
\acrodef{CI/CD}{Continuous Integration and Continuous Deployment}
\acrodef{TCP}{Transmission Control Protocol}

\mainlinespacing{1.241}

\begin{document}
\selectlanguage{italian}

\frontmatter\frontispiece

\begin{dedication}
A te che ci sei sempre stato\\
e sempre sei con me anche se te ne sei andato.\\
A te che tanto mi hai insegnato\\
e sempre mi hai supportato.
\bigbreak
A te che più di chiunque altro avrei voluto qua.
\smallbreak
A mio nonno Gianni.
\end{dedication}

%----------------------------------------------------------------------------------------
\tableofcontents
\listoffigures
%\lstlistoflistings
%----------------------------------------------------------------------------------------

\mainmatter

%----------------------------------------------------------------------------------------
\chapter{Introduzione}
\label{chap:Introduzione}
%----------------------------------------------------------------------------------------
\paragraph{Structure of the Thesis}
\note{At the end, describe the structure of the paper}

\chapter{Background}\label{chap:Background}

\section{Sviluppo Multiplatform}

Lo sviluppo multiplatform è diventato un approccio sempre più diffuso per la creazione di applicazioni che devono essere eseguite
su diverse piattaforme senza dover scrivere codice specifico per ciascuna di esse. Questo approccio consente agli sviluppatori di massimizzare
la condivisione del codice, riducendo i costi di sviluppo e manutenzione e garantendo una maggiore coerenza e compatibilità tra 
le diverse versioni dell'applicazione.

Esistono diversi approcci per lo sviluppo multiplatform, ciascuno con le proprie caratteristiche e vantaggi:
\begin{itemize}
\item \textbf{Codice Condiviso}: In questo approccio il codice condiviso viene scritto una volta e viene compilato per essere eseguito
 su diverse piattaforme. Questo può essere realizzato utilizzando linguaggi di programmazione che supportano la compilazione multiplatform, 
 come Kotlin, o utilizzando framework e librerie che consentono la condivisione del codice tra piattaforme diverse.
\item \textbf{Interfacce di Programmazione (API)}: Un altro approccio consiste nel definire un'API comune che fornisce un'interfaccia uniforme
 per l'accesso alle funzionalità dell'applicazione su diverse piattaforme. Questo consente di implementare la logica dell'applicazione specifica 
 per ciascuna piattaforma, mantenendo al contempo una coerenza nell'interfaccia e nei dati condivisi.
\item \textbf{Virtualizzazione e Contenitori}: Utilizzando tecnologie di virtualizzazione e contenitori, è possibile creare un ambiente uniforme 
per l'esecuzione dell'applicazione su diverse piattaforme. Questo approccio permette di isolare l'applicazione dall'infrastruttura sottostante, 
garantendo una maggiore portabilità e flessibilità.
\end{itemize}

Lo sviluppo multiplatform offre una serie di vantaggi significativi:
\begin{itemize}
\item \textbf{Massimizzazione della Condivisione del Codice}: Condividendo il codice tra le diverse piattaforme 
è possibile ridurre il lavoro ripetitivo e aumentare l'efficienza dello sviluppo.
\item \textbf{Riduzione dei Costi di Sviluppo}: Riducendo il numero di linee di codice da scrivere e gestire 
è possibile ridurre i costi complessivi di sviluppo e manutenzione dell'applicazione.
\item \textbf{Coerenza e Compatibilità}: Mantenendo una sola base di codice per tutte le versioni dell'applicazione 
è possibile garantire una maggiore coerenza e compatibilità tra le diverse versioni.
\item \textbf{Flessibilità}: Utilizzando approcci multiplatform gli sviluppatori possono adottare una varietà di tecnologie e 
linguaggi di programmazione per soddisfare le esigenze specifiche del progetto.
\end{itemize}

\section{Programmazione Distribuita}

Nel contesto dell'informatica moderna, la programmazione distribuita su piattaforme eterogenee emerge come un approccio fondamentale per affrontare le sfide
 della interconnessione in un ambiente eterogeneo di dispositivi e sistemi. Questo paradigma si basa sulla distribuzione delle responsabilità e delle risorse
 su una varietà di dispositivi e piattaforme, che possono differire per architettura hardware, sistema operativo e linguaggio di programmazione.

La programmazione distribuita su piattaforme eterogenee è guidata dalla necessità di integrare e coordinare dispositivi e sistemi diversi per creare soluzioni
 innovative e scalabili. Questo approccio richiede la collaborazione e la comunicazione efficace tra nodi distribuiti, che possono trovarsi in ambienti eterogenei
 come cloud, dispositivi embedded, server on-premise e dispositivi mobili.

Alcune tecnologie e approcci chiave utilizzati nella programmazione distribuita su piattaforme eterogenee includono:

\begin{itemize}
\item \textbf{Protocolli di Comunicazione Universali}: Questi protocolli consentono la comunicazione tra dispositivi e sistemi eterogenei,
 fornendo un'interfaccia standardizzata per lo scambio di dati e messaggi. Esempi di protocolli universali includono HTTP\footnote{
    HTTP (HyperText Transfer Protocol) è un protocollo di comunicazione utilizzato per il trasferimento di ipertesti, 
    come pagine web, su reti informatiche, principalmente il World Wide Web.
 }, \ac{MQTT} e gRPC, che consentono la comunicazione su diverse piattaforme e architetture.
\item \textbf{Middleware Distribuito}: Il middleware distribuito fornisce un livello di astrazione tra le applicazioni e l'infrastruttura sottostante,
 consentendo la trasparenza della distribuzione su piattaforme eterogenee. Questo può includere servizi di messaggistica, servizi di gestione delle transazioni
  e sistemi di caching distribuiti.
\item \textbf{Containerizzazione}: Le tecnologie di containerizzazione, come Docker e Kubernetes, consentono di confezionare,
 distribuire e gestire applicazioni su piattaforme eterogenee in modo uniforme. I container forniscono un'unità di distribuzione leggera e isolata,
  garantendo la portabilità e la scalabilità delle applicazioni su diverse infrastrutture.
\item \textbf{Orchestrazione Multi-Cloud}: L'orchestrazione multi-cloud permette di distribuire carichi di lavoro su più fornitori di servizi cloud,
 garantendo la ridondanza, la resilienza e la flessibilità delle applicazioni su piattaforme eterogenee
\end{itemize}

\section{Protocollo MQTT}

Nel vasto panorama dell' \ac{IoT}, dove milioni di dispositivi sono interconnessi per scambiare dati e informazioni in tempo reale, Message Queuing Telemetry Transport (MQTT) 
si distingue come uno dei protocolli di comunicazione più importanti e ampiamente adottati. In quanto si presenta come una soluzione elegante per risolvere le sfide di 
comunicazione proposte in ambito \ac*{IoT}. Le sue caratteristiche distintive includono il basso utilizzo di banda e CPU, che lo rendono particolarmente adatto per i 
dispositivi con risorse limitate, e il modello di comunicazione publish-subscribe, che consente la trasmissione efficiente dei messaggi anche grazie al protocollo 
\ac{TCP} a cui si appoggia per la trasmissione dei messaggi.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/mqtt-example.png}
    \caption{Esempio di comunicazione tramite MQTT}
    \label{fig:mqtt-example}
\end{figure}

Nel modello publish-subscribe di \ac{MQTT} i dispositivi si dividono in due ruoli principali:
 i publisher, che inviano i messaggi su specifici topic, e i subscriber, che si iscrivono a questi topic per ricevere i messaggi pertinenti. 
 Questo approccio consente una comunicazione flessibile e scalabile, in cui i dispositivi possono interagire in modo dinamico senza la necessità
 di conoscere direttamente gli indirizzi dei destinatari.

Il protocollo \ac{MQTT} è composto da molteplici entità di due tipologie: un singolo broker di messaggi e un numero variablie di client. Il broker \ac{MQTT} è un server 
con la funzione di ricevere i messaggi da tutti i client e di instradarli verso i destinatari interessati. Un client MQTT è un qualsiasi dispositivo che esegue una libreria 
\ac{MQTT} e si connette a un broker \ac{MQTT} e può svolgere sia il ruolo di publisher che di subscriber. Quando un publisher ha nuovi dati da trasmettere, 
invia un messaggio con i dati al broker a cui è connesso. Il broker, quindi, distribuisce le informazioni a tutti i client ch si sono iscritti a quell’argomento. 
Non è necessario che il publisher conosca il numero o la posizione degli iscritti e questi ultimi, a loro volta, non necessitano di alcuna informazione sui publisher.

Un aspetto cruciale del protocollo MQTT è la sua capacità di mantenere aperte le connessioni tra i dispositivi per lunghi periodi, riducendo al minimo la latenza 
e ottimizzando l'efficienza della comunicazione. Questo risulta particolarmente importante in contesti dove è essenziale uno scambio continuo e tempestivo di dati 
in tempo reale, permettendo un monitoraggio costante e affidabile. Tale caratteristica rende MQTT ideale per applicazioni che richiedono una trasmissione dati 
ininterrotta e reattiva, garantendo prestazioni ottimali anche in ambienti con risorse limitate e connettività intermittente.

I principali tipi di messaggi MQTT sono quattro:
\begin{itemize}
    \item \textbf{Connect}: il client attende che venga stabilita una connessione con il broker e crea un collegamento tra i nodi;
    \item \textbf{Disconnect}: attende se il client MQTT deve terminare delle operazioni e poi chiude la sessione TCP/IP;
    \item \textbf{Publish}: il client pubblica un messaggio nella classe specificato;
    \item \textbf{Subscribe}: iscrive il client all’argomento specificato;
\end{itemize}

\subsection{Formato pacchetti MQTT}
Un pacchetto \ac{MQTT} è composto da diverse parti strutturate in modo specifico, può essere suddivisa nelle seguenti componenti principali:

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/mqtt-packet.png}
    \caption{formato di un pacchetto MQTT}
    \label{fig:mqtt-packet}
\end{figure}

\begin{itemize}
\item \textbf{Fixed Header (Intestazione Fissa):} Ogni pacchetto MQTT contiene un'intestazione fissa che è obbligatoria e ha una lunghezza di 2 byte. 
L'intestazione fissa include il tipo di messaggio, il livello di \ac{QoS}, la lunghezza rimanente del pacchetto e informazioni sui flag di controllo
tra cui DUP (duplicate) che indica se è il primo tentativo di invio di tale pacchetto e RET (retain) che indica se tale pacchetto deve essere salvato nel server.
I tipi di messaggio possono includere CONNECT, PUBLISH, SUBSCRIBE, UNSUBSCRIBE, DISCONNECT.
\item \textbf{Variable Header (Intestazione Variabile):} L'intestazione variabile è opzionale e viene utilizzata in base al tipo di pacchetto. 
Questa sezione può includere diversi campi come l'identificatore del pacchetto, i codici di ritorno e altre informazioni specifiche del tipo di messaggio. 
Ad esempio, nei pacchetti di tipo PUBLISH, l'intestazione variabile include il topic del messaggio.
\item \textbf{Payload (Corpo del Messaggio):} Il corpo del messaggio o payload è anch'esso opzionale e contiene i dati effettivi da trasmettere. 
La lunghezza del payload può variare e nei pacchetti PUBLISH, esso contiene il contenuto del messaggio che viene inviato agli abbonati al topic specifico. 
La presenza e il contenuto del payload dipendono dal tipo di messaggio specifico.
\end{itemize}

\subsection{Quality of Service (QoS)}

\ac{MQTT} offre funzionalità avanzate per la gestione delle connessioni, la sicurezza e la qualità del servizio (\ac{QoS}), che consentono di personalizzare e ottimizzare 
la comunicazione in base alle esigenze specifiche dell'applicazione. Queste caratteristiche lo rendono un protocollo estremamente flessibile e adattabile, 
in grado di soddisfare una vasta gamma di requisiti e casi d'uso nell'ambito dell'\ac{IoT}. 
Ogni livello di \ac{QoS} in MQTT offre un trade-off tra affidabilità e overhead di rete, permettendo agli sviluppatori di scegliere il livello più appropriato in base alle esigenze 
specifiche dell'applicazione semplicemente modificando il valore dei due bit che indicano il livello QoS nei pachetti, tramite le APi fornite dalle librerie. 

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/mqtt-qos.png}
    \caption{funzionamento dei diversi livelli di QoS}
    \label{fig:mqtt-qos}
\end{figure}

Il livello di \ac{QoS} 0, noto anche come `al massimo una volta' (at most once), garantisce che i messaggi vengano inviati senza conferma di ricezione. 
I messaggi vengono consegnati in modo best effort, il che significa che non ci sono garanzie di consegna. Questo livello di \ac{QoS} è utilizzato quando la perdita 
di messaggi occasionali è accettabile, come nelle applicazioni dove la latenza è più importante dell'affidabilità, ad esempio per il monitoraggio di dati in tempo reale 
che vengono aggiornati frequentemente.

Il livello di \ac{QoS} 1, noto anche come `almeno una volta' (at least once), garantisce che i messaggi vengano consegnati almeno una volta al destinatario. Ciò implica 
che il mittente continua a inviare il messaggio finché non riceve una conferma di ricezione (acknowledgement) dal destinatario. Tuttavia, questo può portare alla possibilità 
di ricevere duplicati del messaggio. Il livello \ac{QoS} 1 è utilizzato quando è importante che i messaggi vengano ricevuti, anche se ciò significa ricevere duplicati, 
ad esempio per le transazioni di dati critici che devono essere garantite.

Il livello di \ac{QoS} 2, noto anche come `esattamente una volta' (exactly once), garantisce che ogni messaggio venga consegnato esattamente una volta al destinatario. 
Questo livello di \ac{QoS} utilizza un meccanismo di handshake a quattro fasi per assicurare che i messaggi non vengano duplicati e non vadano persi, garantendo la massima 
affidabilità. Questo livello di \ac{QoS} è utilizzato in scenari dove è fondamentale evitare duplicati e garantire la consegna esatta di ogni messaggio, come nelle applicazioni 
finanziarie o nei sistemi di controllo industriale.

\pagebreak %avoids first 2 line of next subsection to be at the bottom of the page
\subsection{MQTT over WebSocket}

MQTT over WebSocket rappresenta una combinazione potente che estende le capacità del protocollo \ac{MQTT} nel contesto delle applicazioni web. WebSocket è un protocollo 
di comunicazione che fornisce un canale full-duplex su una singola connessione \ac{TCP}, consentendo una comunicazione bidirezionale in tempo reale tra il client e il server.

L'integrazione di \ac{MQTT} con WebSocket permette ai client basati su web di comunicare direttamente con un broker \ac{MQTT}, eliminando la necessità di intermediari o di 
soluzioni di polling inefficaci. Questo è particolarmente utile per le applicazioni \ac{IoT} che richiedono aggiornamenti in tempo reale e un'interazione continua tra 
dispositivi e interfacce utente basate su web. Le principali caratteristiche di MQTT over WebSocket includono:

\begin{itemize}
    \item \textbf{Compatibilità Browser}: 
    Consente ai browser web di stabilire connessioni \ac{MQTT} direttamente, facilitando lo sviluppo di applicazioni web interattive e in tempo reale.
    \item \textbf{Efficienza della Connessione}: 
    Utilizza una singola connessione \ac{TCP} per gestire sia il canale di comunicazione \ac{MQTT} che la trasmissione dei dati, riducendo il sovraccarico di rete.
    \item \textbf{Sicurezza}: 
    Supporta la crittografia SSL/TLS per garantire che la comunicazione tra il client e il server sia sicura, proteggendo i dati trasmessi da intercettazioni e attacchi.
    \item \textbf{Flessibilità}: 
    Permette una facile integrazione con le infrastrutture web esistenti, utilizzando lo stesso stack di tecnologia web e riducendo la complessità del sistema.
\end{itemize}

MQTT over WebSocket è ideale per le applicazioni che necessitano di aggiornamenti frequenti e rapidi, come dashboard di monitoraggio, sistemi di allarme in tempo reale, 
e applicazioni di controllo remoto. La combinazione di \ac{MQTT} e WebSocket offre una soluzione robusta e scalabile per la comunicazione in tempo reale nel mondo dell'\ac{IoT}.

\section{Dependency Injection}

Nel contesto dell'ingegneria del software, la \textit{Dependency Injection} rappresenta un pattern di progettazione fondamentale per la gestione
 delle dipendenze tra i vari componenti di un sistema. Questo approccio promuove un'architettura modulare e facilita la manutenzione, il testing e l'estensibilità del software.

La Dependency Injection è una tecnica attraverso la quale un oggetto (il \textit{client}) riceve le proprie dipendenze da un oggetto esterno 
(l' \textit{injector}), anziché crearle autonomamente. Le dipendenze sono componenti di cui il client ha bisogno per eseguire le proprie funzionalità.
 In altre parole, la Dependency Injection inverte il controllo della creazione delle dipendenze, trasferendo questa responsabilità a un container o a un framework.

Esistono tre principali varianti di Dependency Injection:
\begin{itemize}
\item \textbf{Constructor Injection}: Le dipendenze vengono fornite tramite il costruttore dell'oggetto. 
    Questo metodo garantisce che le dipendenze siano disponibili al momento della creazione dell'oggetto.
\item \textbf{Setter Injection}: Le dipendenze vengono fornite tramite metodi setter. 
    Questo approccio consente una maggiore flessibilità nella configurazione delle dipendenze dopo la creazione dell'oggetto.
\item \textbf{Interface Injection}: L'oggetto client espone un'interfaccia che permette al container di fornire le dipendenze. 
    Questo metodo è meno comune ma può essere utile in contesti specifici.
\end{itemize}

L'adozione della Dependency Injection offre numerosi vantaggi, tra cui:
\begin{itemize}
    \item \textbf{Maggiore modularità}: I componenti del sistema possono essere sviluppati e testati in isolamento, migliorando la coesione e riducendo l'accoppiamento.
    \item \textbf{Facilità di testing}: Le dipendenze possono essere sostituite con mock o stub, semplificando il processo di unit testing.
    \item \textbf{Manutenzione e estensibilità migliorate}: La separazione delle preoccupazioni facilita la modifica e l'estensione delle funzionalità del sistema
     senza impattare sul resto del codice.
    \item \textbf{Inversione del controllo}: La Dependency Injection implementa il principio di inversione del controllo,
     permettendo al framework di gestire il ciclo di vita degli oggetti e le loro dipendenze.
\end{itemize}

Diversi framework e container sono stati sviluppati per supportare la Dependency Injection in vari linguaggi di programmazione. Un esempio prominente, 
 in particolare per l'ecosistema Kotlin, è \textbf{Koin}: un framework di Dependency Injection per Kotlin che si distingue per la sua semplicità e leggerezza. 
 Koin utilizza una DSL (Domain Specific Language) per definire le dipendenze in modo chiaro e conciso, rendendo l'integrazione e la configurazione estremamente intuitive.
 Koin è particolarmente apprezzato nell'ambito dello sviluppo di applicazioni Android.

La Dependency Injection è un pattern di progettazione che offre una soluzione elegante alla gestione delle dipendenze in sistemi software complessi.
 La sua adozione consente di sviluppare applicazioni modulari, testabili e facilmente manutenibili, contribuendo a migliorare la qualità complessiva del software.
 Nelle sezioni successive, esploreremo più in dettaglio i vari aspetti della Dependency Injection, i suoi benefici e come implementarla efficacemente utilizzando diversi framework,
 con un focus particolare su Koin per applicazioni Kotlin.
    
 \section{PulvReAKt}
PulvReAKt è un framework leggero e multipiattaforma per Kotlin, progettato per facilitare la pulverizzazione dei sistemi, ovvero la suddivisione di applicazioni complesse
 in muyltemplici componenti modulari che possono essere distribuiti su diverse piattaforme. Il framework supporta \ac{JVM}, \ac{JS} e alcune piattaforme native, come Linux, macOS e iOS. 
 PulvReAKt consente di definire, configurare e distribuire componenti software utilizzando protocolli di comunicazione come \ac{MQTT} e RabbitMQ, rendendolo particolarmente adatto 
 per lo sviluppo di applicazioni distribuite e sistemi \ac{IoT}. Consente di suddividere l'applicazione in componenti indipendenti, facilitando lo sviluppo e la manutenzione. 
 Supporta \ac{JVM}, \ac{JS} e varie piattaforme native, permettendo l'esecuzione dei componenti in diversi ambienti.
 
\section{Kotlin}
La scelta del linguaggio utilizzato per questo progetto è stata relativamente semplice, poiché il progetto PulvReAKt, nel quale è contestualizzato, 
è scritto interamente in Kotlin con target Multiplatform. La maggior parte dello sviluppo è stata eseguita in Kotlin, con l'unica eccezione dell'utilizzo di una libreria 
JavaScript per lo sviluppo della parte \ac{JS}, integrata comunque all'interno di Kotlin grazie alla sua interoperabilità.

Kotlin è un linguaggio di programmazione moderno sviluppato da JetBrains, noto per il suo approccio pragmatico e la sua forte interoperabilità con Java. 
Dal suo lancio nel 2011, Kotlin ha guadagnato rapidamente popolarità, diventando nel 2017 il linguaggio ufficiale per lo sviluppo di applicazioni Android. 

Kotlin è stato progettato per essere conciso, riducendo la quantità di codice boilerplate necessario. Grazie alle funzioni lambda e alle estensioni di funzioni, 
il codice scritto in Kotlin risulta più leggibile e mantenibile rispetto a Java. Inoltre, Kotlin si propone di minimizzare gli errori a runtime, 
spostando la rilevazione degli errori al tempo di compilazione.

Uno dei punti di forza di Kotlin è la sua totale interoperabilità con Java. Questo significa che il codice Kotlin può chiamare ed essere chiamato da codice Java senza difficoltà. 
Questo facilita la migrazione graduale da Java a Kotlin nei progetti esistenti, permettendo agli sviluppatori di integrare Kotlin in maniera incrementale.

Kotlin introduce le coroutines, una potente astrazione per la programmazione asincrona e concorrente. Le coroutines offrono un modo semplice ed efficiente per gestire operazioni
che altrimenti richiederebbero la gestione complessa dei thread. Esse permettono di scrivere codice asincrono in uno stile sequenziale, migliorando la leggibilità e
riducendo il rischio di errori.

Le coroutines in Kotlin sono supportate a livello di linguaggio, con una libreria standard che fornisce molte funzionalità pronte all'uso. 
Ecco alcuni dei principali vantaggi delle coroutines:

\begin{itemize}
    \item \textbf{Semplicità del codice asincrono:} Le coroutines permettono di scrivere codice che sembra sincrono ma che viene eseguito in modo asincrono, 
    semplificando notevolmente la gestione delle operazioni I/O e altre operazioni bloccanti.
    \item \textbf{Efficienza delle risorse:} Le coroutines sono molto leggere rispetto ai thread tradizionali. Possono essere sospese e riprese senza un costo significativo, 
    consentendo una gestione efficiente delle risorse.
    \item \textbf{Facilità di cancellazione:} Le coroutines forniscono meccanismi per gestire la cancellazione delle operazioni in corso, 
    riducendo il rischio di risorse bloccate o perdite di memoria.
    \item \textbf{Composizione semplice:} Le coroutines permettono di comporre in modo semplice operazioni asincrone, rendendo il codice più modulare e facile da mantenere.
\end{itemize}

L'utilizzo delle coroutines in Kotlin rappresenta un approccio moderno alla programmazione concorrente, 
semplificando notevolmente il processo di scrittura e gestione del codice asincrono.

La sintassi concisa e le caratteristiche avanzate di Kotlin contribuiscono ad aumentare la produttività degli sviluppatori. 
Funzionalità come le funzioni di estensione, la gestione avanzata delle nullità e le espressioni lambda riducono il codice boilerplate e semplificano lo sviluppo, 
permettendo agli sviluppatori di concentrarsi sulla logica applicativa piuttosto che sui dettagli implementativi.

La forte tipizzazione e le funzionalità di sicurezza integrata di Kotlin contribuiscono a migliorare la qualità del codice. 
Il compilatore di Kotlin è in grado di rilevare molti tipi di errori a tempo di compilazione, riducendo il numero di bug presenti nel software finito. Inoltre, 
la gestione avanzata delle nullità e le funzioni di estensione aiutano a scrivere codice più robusto e meno incline agli errori.

Uno degli aspetti più potenti di Kotlin è la sua capacità di supportare lo sviluppo multiplatform. Grazie al quale gli sviluppatori possono scrivere 
un unico set di codice Kotlin che può essere condiviso e utilizzato su diverse piattaforme, come la \ac{JVM}, JavaScript e la compilazione nativa. 
Questo approccio consente agli sviluppatori di massimizzare la condivisione del codice, riducendo al minimo la duplicazione e semplificando la manutenzione dell'applicazione 
su più piattaforme.

\chapter{Requisiti}\label{chap:Requisiti}

\section{Requisiti funzionali}

Il progetto si propone di offrire un gestore delle comunicazioni utilizzabile in diversi ambiti, in particolare è stato progettato con in mente le funzionalità necessarie
all'interno di un sistema distribuito ed eterogeneo quale PulvReAKt, nel quale è stato poi integrato in un secondo momento. 
Caratterizzato dalla presenza di componenti dislocate in posizioni geografiche diverse e con capacità e risorse variabili. 
Questo sistema deve essere in grado di operare efficacemente in contesti molto diversificati, inclusi quelli \ac{IoT}, dove le macchine coinvolte 
dispongono spesso di risorse hardware limitate. Inoltre, il sistema deve essere progettato per funzionare correttamente anche in ambienti 
con connettività di rete instabile o variabile, garantendo prestazioni adeguate indipendentemente dalle condizioni di rete.

Uno degli obiettivi principali del progetto è assicurare che le comunicazioni avvengano in modo efficiente e affidabile, con particolare attenzione a garantire 
che i messaggi vengano recapitati esclusivamente ai destinatari interessati. Questo richiede l'implementazione di meccanismi sofisticati di gestione dei messaggi, 
che consentano un indirizzamento preciso e prevengano lo spreco di risorse. La capacità di indirizzare correttamente i messaggi è fondamentale per evitare 
sovraccarichi di rete e per mantenere l'integrità e la sicurezza delle comunicazioni.

La gestione dei canali di comunicazione deve essere trasparente per l'utente finale. Tuttavia, è responsabilità dell'utente formattare correttamente i messaggi, 
poiché il sistema è progettato per ricevere il messaggio in input, insieme alle entità sorgente e destinazione, e per inviarlo al destinatario corretto mantenendo 
l'integrità del mittente e del contenuto del messaggio. La formattazione non sarà unificata se non per quanto riguarda l'incapsulamento necessario per garantire l'invio e 
la ricezione corretti dei messaggi, utilizzando il protocollo \ac{MQTT}. 

\section{Scalabilità}
Il modulo di comunicazione sviluppato per il sistema di pulverizzazione e computazione distribuita PulvReAKt deve supportare la scalabilità orizzontale, permettendo l'aggiunta 
di nuovi nodi senza interruzioni del servizio. Questo implica che l'architettura deve essere in grado di adattarsi dinamicamente all'aumento delle richieste, distribuendo il carico 
tra i nuovi nodi in modo efficiente. Una soluzione di scalabilità orizzontale efficace dovrebbe prevedere meccanismi di auto-scaling, dove i nuovi nodi vengono aggiunti 
automaticamente in risposta a picchi di carico e ridotti durante i periodi di bassa domanda, ottimizzando l'uso delle risorse e minimizzando i costi operativi. Inoltre, 
il sistema deve essere in grado di gestire l'elasticità dell'infrastruttura, permettendo il provisioning e de-provisioning dei nodi in maniera automatizzata e senza interruzioni.

Per gestire la comunicazione diretta tra molteplici componenti, è stata scelta una struttura dei topic \ac{MQTT} con un topic principale (PulvReAKt) all'interno del quale avvengono 
tutte le comunicazioni, secondo una struttura organizzata gerarchicamente. Seguendo lo schema PulvReAKt/mittente/destinatario, ad esempio, se un componente A volesse scrivere a un 
componente B, il topic del messaggio sarebbe PulvReAKt/A/B. Questo approccio consente una gestione ordinata e tracciabile della comunicazione, facilitando la manutenzione e 
l'analisi dei flussi di messaggi all'interno del sistema distribuito.

Inoltre, questa struttura permette di filtrare e gestire facilmente i messaggi in base alla sorgente e alla destinazione, migliorando l'efficienza della comunicazione e riducendo 
il rischio di collisioni o confusione tra i messaggi inviati dai diversi componenti. La scelta di una struttura dei topic chiara e ben definita è cruciale per assicurare che la 
comunicazione tra i componenti rimanga scalabile e mantenibile man mano che il sistema cresce e si evolve.

\section{Affidabilità}
Un aspetto cruciale nella comunicazione tra i componenti è che deve essere robusta e affidabile per garantire il corretto funzionamento del sistema distribuito. I componenti 
devono poter inviare e ricevere messaggi utilizzando il protocollo di comunicazione \ac{MQTT}. Questo richiede l'integrazione di librerie specifiche per \ac{MQTT}, assicurando 
che i messaggi possano essere formattati, inviati e ricevuti correttamente. Deve essere garantita l'affidabilità nella consegna dei messaggi, in alcuni casi assicurando che ogni 
messaggio venga ricevuto dal destinatario previsto. Ciò implica la gestione di conferme di ricezione, meccanismi di ritrasmissione in caso di fallimento e 
gestione delle code di messaggi per evitare perdite, che sono tutti compresi all'interno del protocollo \ac{MQTT} in caso si decida di usare una \ac{QoS} di livello 1 o 2.

La gestione delle code di messaggi è un'altra componente critica. Un sistema di coda ben progettato può aiutare a prevenire la perdita di messaggi in situazioni di traffico elevato 
o in caso di disconnessioni temporanee. Implementare meccanismi di bufferizzazione e di ritrasmissione può migliorare significativamente l'affidabilità complessiva del sistema.

Il modulo di comunicazione deve includere funzionalità di logging e monitoraggio per tracciare l'attività e le performance del sistema. Questi strumenti permettono di identificare 
e risolvere rapidamente eventuali problemi, migliorando la reattività del sistema alle condizioni di errore. Il logging dettagliato degli eventi di comunicazione aiuta anche nella 
diagnosi e nella prevenzione di guasti futuri, fornendo dati preziosi per l'analisi delle cause principali dei problemi.

L'implementazione di meccanismi di failover e ripristino automatico è essenziale per garantire la disponibilità continua del servizio. Ad esempio, l'uso di cluster di broker MQTT 
ridondanti può prevenire l'interruzione del servizio in caso di guasto di uno dei nodi. Inoltre, la configurazione di backup e ripristino regolari dei dati critici garantisce che 
il sistema possa essere rapidamente riportato allo stato operativo in caso di disastri.

L'affidabilità può essere ulteriormente migliorata attraverso l'uso di tecniche di testing rigorose, come i test di stress e i test di carico, per valutare le prestazioni del 
sistema sotto condizioni estreme. L'adozione di pratiche DevOps, con pipeline \ac{CI/CD}, assicura che le nuove versioni del software 
vengano distribuite in modo sicuro e senza interruzioni, mantenendo un elevato standard di qualità e affidabilità.

\section{Interoperabilità}

L'interoperabilità si riferisce alla capacità dei diversi sistemi e componenti software di lavorare insieme senza problemi, scambiando dati e utilizzando le informazioni scambiate 
in modo efficace. Nel contesto di PulvReAKt, questo significa che i componenti sviluppati per \ac{JVM} devono poter interagire con quelli sviluppati in JavaScript o con quelli 
che girano su piattaforme native. Questo richiede che il protocollo di comunicazione, in questo caso \ac{MQTT}, sia implementato in modo standard e conforme su tutte le piattaforme.

\subsection{Java Virtual Machine}

La \ac{JVM} è una macchina virtuale che esegue bytecode Java, ed è la piattaforma di riferimento per lo sviluppo in Java e Kotlin. 
Essa offre una serie di caratteristiche che la rendono una scelta popolare per l'implementazione di applicazioni complesse e ad alte prestazioni.
Le caratteristiche principali della \ac{JVM} sono:

\begin{itemize}
\item \textbf{Interoperabilità}: La \ac{JVM} permette l'interoperabilità tra Kotlin e Java, consentendo l'uso di librerie e strumenti Java consolidati, 
 permettendo agli sviluppatori di sfruttare l'ampio ecosistema Java esistente.
\item \textbf{Portabilità}: Il bytecode generato può essere eseguito su qualsiasi dispositivo dotato di una \ac{JVM}, garantendo portabilità cross-platform. 
Questo è particolarmente utile per le applicazioni distribuite su una vasta gamma di dispositivi e sistemi operativi.
\item \textbf{Ottimizzazioni di Runtime}: La \ac{JVM} include un Just-In-Time (JIT) compiler che ottimizza il codice durante l'esecuzione, migliorando le performance e 
consentendo un'esecuzione più veloce delle applicazioni Kotlin rispetto a linguaggi interpretati o compilati staticamente.
\item \textbf{Garbage Collection}: Gestione automatica della memoria tramite garbage collection, riducendo il rischio di memory leaks. 
Allevia gli sviluppatori dalla necessità di gestire manualmente l'allocazione e la deallocazione della memoria, semplificando lo sviluppo e riducendo il rischio di errori.
\end{itemize}

\subsection{JavaScript e Node.js}

JavaScript è il linguaggio di scripting dominante per lo sviluppo web client-side, eseguito all'interno dei browser. Kotlin/\ac{JS} permette di compilare codice Kotlin in JavaScript, 
sfruttando le capacità di questa piattaforma. Le caratteristiche principali di \ac{JS} sono:

\begin{itemize}
\item \textbf{Compatibilità con il Web}: JavaScript è nativamente supportato dai browser, permettendo l'esecuzione di applicazioni Kotlin/\ac{JS} direttamente nel contesto web e 
consente agli sviluppatori di creare applicazioni web interattive e dinamiche utilizzando Kotlin come linguaggio di sviluppo.
\item \textbf{Ecosistema di Librerie}: Ampia disponibilità di librerie e framework per lo sviluppo web, che possono essere utilizzati anche con Kotlin/\ac{JS}. 
Include librerie per la gestione del DOM\footnote{
    DOM (Document Object Model): Rappresentazione ad albero di un documento HTML/XML che permette di accedere e modificare dinamicamente la struttura e 
    il contenuto delle pagine web.
}, l'interazione con API REST\footnote{
    API REST (Representational State Transfer): Insieme di convenzioni per creare servizi web che permettono la comunicazione 
    tra client e server utilizzando operazioni HTTP standard.
}, la manipolazione dei dati JSON\footnote{
    JSON (JavaScript Object Notation): Formato di testo leggero per lo scambio di dati, facilmente leggibile dagli umani e parsabile dai computer.
} 
e molto altro ancora, consentendo quindi agli sviluppatori di sfruttare le funzionalità esistenti senza doverle implementare nuovamente.
\item \textbf{Asincronia}: Supporto nativo per le operazioni asincrone tramite callback, Promises e async/await che vanno a sopperire alla mancanza di capacità multithread 
essendo progettato per lavorare anche in contesto browser, quindi con un singolo thread. Questa particolarita è estremamente utile per le applicazioni web che devono gestire 
operazioni di rete, come il caricamento di dati da un server remoto.
\item \textbf{Interoperabilità}: Kotlin/\ac{JS} permette l'interoperabilità con le API JavaScript esistenti, facilitando l'integrazione con altre tecnologie web,
consentendo agli sviluppatori di utilizzare librerie e framework JavaScript esistenti all'interno del codice Kotlin, con una maggiore flessibilità 
e libertà di scelta nella progettazione delle applicazioni.
\end{itemize}

\begin{itemize}
\item \textbf{Node.js} rappresenta una potente piattaforma per lo sviluppo backend, estendendo le capacità di JavaScript oltre il browser e offrendo un ambiente efficiente e scalabile 
per la creazione di applicazioni server-side moderne. Utilizzando Node.js, gli sviluppatori possono beneficiare di un ecosistema ricco di strumenti avanzati per costruire
applicazioni robuste e performanti.
\item \textbf{Event-driven e Non-blocking I/O}: Node.js utilizza un modello event-driven e non-blocking per le operazioni di I/O, consentendo di gestire un numero elevato di connessioni
 concorrenti con un singolo thread grazie al meccanismo delle promise in \ac{JS}.
\item \textbf{Ecosistema di Moduli }: Node.js ha un vasto ecosistema di moduli e pacchetti disponibili tramite npm (Node Package Manager). 
Questi moduli coprono una vasta gamma di funzionalità, come la gestione del database, la manipolazione dei file e la creazione di server wen. 
\end{itemize}

\subsection{Native}

Kotlin/Native permette di compilare codice Kotlin direttamente in codice macchina eseguibile su dispositivi target, senza la necessità di una macchina virtuale o un interprete.
Le caratteristche principali delle diverse piattaforme native sono:

\begin{itemize}
\item \textbf{Esecuzione Diretta}: Compilazione in codice nativo che viene eseguito direttamente dall'hardware, senza layer di interpretazione. 
Si traduce in prestazioni superiori rispetto alle applicazioni eseguite su una macchina virtuale o interprete, poiché non vi è alcun overhead dovuto alla traduzione 
del bytecode in istruzioni di macchina.
\item \textbf{Performance}: Le applicazioni native tendono ad avere performance superiori rispetto a quelle eseguite su una macchina virtuale o interprete, 
grazie alla compilazione diretta. Questo è particolarmente importante per le applicazioni ad alte prestazioni che richiedono un tempo di risposta rapido e una bassa latenza.
\item \textbf{Accesso a Funzionalità di Sistema}: Possibilità di accedere direttamente alle API di sistema e alle risorse hardware, offrendo maggior controllo e ottimizzazione. 
Consente agli sviluppatori di creare applicazioni che interagiscono direttamente con l'hardware sottostante, sfruttando appieno le capacità del dispositivo target.
\item \textbf{Assenza di Overhead}: Sebbene Kotlin/Native includa un garbage collector, quando viene eseguito su piattaforme native non vi è nessun overhead dovuto alla 
gestione della macchina virtuale. Questo significa che le risorse del sistema possono essere utilizzate in modo più efficiente, riducendo il consumo di memoria e CPU.
\item \textbf{Cross-platform}: La capacità di supportare per diverse piattaforme, inclusi iOS, Windows, Linux e macOS, facilita lo sviluppo di applicazioni multi-piattaforma, 
consente agli sviluppatori di scrivere un'unica base di codice Kotlin che può essere compilato ed eseguito su una varietà di dispositivi e sistemi operativi, 
riducendo al minimo lo sforzo di sviluppo e la complessità del codice.
\end{itemize}

\chapter{Design}\label{chap:Design}

\section{Struttura delle classi}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/class-diagram.png}
    \caption{Diagramma delle classi}
    \label{fig:class-diagram}
\end{figure}

Il diagramma delle classi presentato in Figura\ref{fig:class-diagram} illustra l'architettura e le relazioni tra le interfacce di PulvReAKt e le classi implementate nel progetto. 
Di seguito, viene fornita una descrizione dettagliata di ciascun componente e delle loro interazioni:

\begin{itemize}
    \item \texttt{InjectAwareResource}: è un'interfaccia che definisce il metodo utilizzato per configurare l'iniettore delle dipendenze.

    \item \texttt{ProtocolError}: è un'interfaccia che rappresenta gli errori relativi al protocollo. Viene implementata da due classi concrete:
    \begin{itemize}
        \item \texttt{EntityNotRegistered}: rappresenta un errore che si verifica quando un'entità non è registrata.
        \item \texttt{ProtocolException}: rappresenta un'eccezione generale del protocollo.
    \end{itemize}

    \item \texttt{Protocol}: è un'interfaccia che definisce i metodi essenziali per la gestione del protocollo di comunicazione. Questi metodi includono:
    \begin{itemize}
        \item \texttt{setupChannel}: metodo per configurare il canale di comunicazione tra due entità \texttt{source} e \texttt{destination}. 
        Una volta chiamato il setup sarà valiudo per tutto il tempo di eseguzione, sarà quindi sufficiente chiamarlo una volta per ogni coppia 
        \texttt{source} e \texttt{destination}. Questo metodo è trasparente all'utente finale, che non dovrebbe mai interagire direttamente con questo metodo.
        \item \texttt{writeToChannel}: Metodo per scrivere dati sul canale di comunicazione specificato. Questo metodo può riuscire 
        o fallire con un \texttt{ProtocolError}. Fallisce se le entità \texttt{from} e \texttt{to} non sono registrate nel protocollo tramite il metodo \texttt{setupChannel}.
        \item \texttt{readFromChannel}: Metodo per leggere dati dal canale di comunicazione specificato. Questo metodo restituisce un \texttt{Flow} 
        caldo di messaggi che può essere consumato dal runtime. Può riuscire o fallire restituendo un \texttt{ProtocolError}. Fallisce se le entità \texttt{from} e \texttt{to} 
        non sono registrate nel protocollo tramite il metodo \texttt{setupChannel}.
    \end{itemize}

    \item \texttt{MqttProtocol}: Una classe concreta che implementa l'interfaccia \texttt{Protocol}. Questa classe fornisce l'implementazione specifica per il protocollo MQTT, 
    includendo i metodi definiti in \texttt{Protocol}. L'implementazione in \texttt{MqttProtocol} sfrutta le funzionalità di MQTT per gestire le comunicazioni tra i nodi nel sistema 
    distribuito.

\end{itemize}


\section{Struttura dei Package}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/package-diagram.png}
    \caption{Diagramma dei package}
    \label{fig:diagramma-package}
\end{figure}

Dovendo il progetto funzionare su diverse Piattaforme, si è cercato di unificare quanti più target possibili, in modo tale da potere scrivere e revisionare il codice una sola volta,
si è riusciti ad utilizzare una libreria comune e di conseguenza un modulo unificato per lo sviluppo di \ac{JVM} e native,.
Mentre, data la natura singlethread di \ac{JS} è stato necessario separare il target dagli altri due, si è quindi optato per una libreria specifica 
per lo sviluppo con target NodeJS, in modo che questa fosse ottimizzata per l'ambiente specifico. 

Per questo motivo, il progetto è stato strutturato in modo tale da avere moduli distinti per ciascun ambiente, con un modulo specifico per \ac{JS} 
e un modulo comune per \ac{JVM} e native.  Entrambi questi moduli implementano una API fornita nel modulo comune (\texttt{commonMain}) grazie
alla struttura degli \texttt{expected} e degli \texttt{actual} fornita da Kotlin apposta per queste casistiche, in cui le stesse funzionalità
e gli stessi metodi devono essere comuni alle diverse piattaforme ma richiedono implementazioni o librerie sottostanti differenti.

Il modulo comune per la \ac{JVM} e native è chiamato \texttt{jvmNativeMain} e contiene 
un'implementazione comune ai due target. Questo modulo include tutte le funzionalità che possono essere eseguite in un ambiente multithread, 
sfruttando le capacità di concorrenza della \ac{JVM} e delle piattaforme native. In \texttt{jvmNativeMain} sono implementati i componenti core del sistema, 
garantendo che la logica di base sia condivisa e riutilizzabile tra le diverse piattaforme. Questo approccio riduce la duplicazione 
del codice e facilita la manutenzione del progetto.

Dalla struttura di \texttt{jvmNativeMain} dipendono due moduli specifici per ogni target:
\begin{itemize}
    \item \texttt{jvmMain}: Questo modulo estende \texttt{jvmNativeMain} per includere ottimizzazioni e integrazioni necessarie per funzionare efficacemente in un ambiente \ac{JVM}. Qui vengono implementate le funzionalità specifiche che sfruttano le caratteristiche avanzate della \ac{JVM}, come la gestione avanzata dei thread e l'ottimizzazione delle prestazioni.
    \item \texttt{nativeMain}: Questo modulo estende \texttt{jvmNativeMain} per le piattaforme native, includendo le implementazioni necessarie per funzionare su tali ambienti. Viene adattato per sfruttare le peculiarità delle diverse piattaforme native, garantendo efficienza e compatibilità con il codice nativo.
\end{itemize}

Per quanto riguarda lo sviluppo con \ac{JS}, data la natura singlethread dell'ambiente, si è sviluppato un modulo specifico chiamato \texttt{jsMain}. 
Questo modulo contiene le implementazioni necessarie per funzionare con NodeJS, adattandosi alle caratteristiche dell'ambiente singlethread. \texttt{jsMain} è stato progettato 
per garantire che tutte le operazioni asincrone e le chiamate di rete siano gestite in modo efficiente, sfruttando il modello event-driven di NodeJS.

In aggiunta ai moduli funzionali, è stato creato un modulo comune per i test chiamato \texttt{commonTest}. Questo modulo contiene tutti i test necessari per verificare 
l'API comune tra i diversi target. Utilizzando \texttt{commonTest}, è possibile garantire che tutte le funzionalità comuni siano testate in modo uniforme su tutte le piattaforme, 
assicurando la coerenza e l'affidabilità del progetto. I test inclusi in \texttt{commonTest} coprono una vasta gamma di scenari, dalle unit test alle integration test, assicurando che 
ogni parte del sistema funzioni correttamente sia individualmente che nel contesto dell'intero progetto.

\section{Struttura di MQTT}

La discrepanza tra il modello caratteristico di \ac{MQTT} di tipo publish-subscribe e la necessità di comunicazione diretta tra le entità, 
che il progetto si propone di offrire, rende necessaria un'attenta definizione della struttura dei topic di \ac{MQTT}. Per affrontare questa sfida, 
è stato deciso di strutturare i topic nella forma \texttt{nomeProgetto/mittente/destinatario}. In questa struttura, `nomeProgetto' rappresenta un topic 
unico all'interno del progetto, che al suo interno ospita tutti i topic necessari per la comunicazione tra le singole entità. Ad esempio, nel progetto PulvReAKt, 
il nome del progetto è `PulvReAKt', ma può essere personalizzato tramite il costruttore del gestore delle comunicazioni.
I componenti `mittente' e `destinatario' rappresentano rispettivamente il nome dell'entità che invia il messaggio e il nome dell'entità a cui è destinato. 
I nomi di queste entità sono definiti esternamente al modulo comunicativo, pertanto è responsabilità dell'utente garantirne l'unicità all'interno del sistema 
per evitare ambiguità. In alternativa, l'utente può utilizzare nomi comuni tra le entità che devono ricevere gli stessi messaggi per motivi logistici.

Per quanto riguarda le caratteristiche dei messaggi inviati e ricevuti, è stato deciso di utilizzare come impostazione predefinita il livello di \ac{QoS} 2 (exactly once), 
poiché è il livello più affidabile, anche se meno efficiente. Tuttavia, si offre all'utente la possibilità di specificare un valore diverso per il livello di \ac{QoS}, 
il valore del ServerKeepAlive (impostato di default a 10 secondi) e il flag retain del messaggio (impostato di default a true). 

Il payload dei messaggi viene trattato con attenzione: viene preso e inserito all'interno del pacchetto \ac{MQTT} esattamente come ricevuto dall'utente, inviato al broker, 
e successivamente rimosso dal pacchetto \ac{MQTT} per essere restituito all'entità destinataria. Questa gestione assicura che il contenuto del messaggio mantenga la sua 
integrità e che la comunicazione avvenga in modo trasparente ed efficace, rispettando le esigenze di affidabilità e performance del sistema.

Si è inoltre scelto di optare per l'utilizzo di \ac{MQTT} over WebSocket, in cui il pacchetto \ac{MQTT} viene inserito all'interno di un messaggio WebSocket per diversi motivi.
Il principale motivo di questa scelta è la maggiore efficienza nell'utilizzo della rete, in quanto WebSocket fornisce un canale full-duplex su una singola connessione \ac{TCP}.
Questa forma utilizza una singola connessione TCP per gestire sia il canale di comunicazione MQTT che la trasmissione dei dati, riducendo quindi il sovraccarico di rete.
Un altro fattore importante nella scelta è il fatto che il protocollo WebSocket consente alle comunicazioni \ac{MQTT} di utilizzare le strutture HTTP già esistenti 
quali la porta HTTP 80, firewall e proxy, strutture che non sarebbero invece usufruibili in caso di utilizzo di \ac{MQTT} tramite \ac{TCP} direttamente.

Si è inoltre deciso di optare per l'utilizzo di \ac{MQTT} over WebSocket, in cui il pacchetto \ac{MQTT} viene inserito all'interno di un messaggio WebSocket per diversi motivi.
Il principale motivo di questa scelta è la maggiore efficienza nell'utilizzo della rete, poiché WebSocket fornisce un canale full-duplex su una singola connessione \ac{TCP}. 
Questa configurazione utilizza una singola connessione TCP per gestire sia il canale di comunicazione MQTT sia la trasmissione dei dati, riducendo il sovraccarico di rete. 
In tal modo, si ottiene un miglioramento significativo delle prestazioni complessive del sistema, garantendo una comunicazione più fluida ed efficiente.
Un altro fattore importante nella scelta di WebSocket è la compatibilità con le infrastrutture HTTP esistenti. WebSocket consente alle comunicazioni \ac{MQTT} 
di utilizzare strutture HTTP già presenti, come la porta HTTP 80, firewall e proxy. Questi elementi non sarebbero utilizzabili nel caso di utilizzo di \ac{MQTT} tramite 
\ac{TCP} direttamente. Questa compatibilità offre un ulteriore vantaggio in termini di sicurezza e gestione della rete, facilitando l'integrazione del protocollo \ac{MQTT} 
in ambienti con restrizioni di rete più rigide.

\section{Struttura dei Test}

Il modulo contenente i test valuta in maniera approfondita la robustezza del progetto attraverso una serie di scenari distinti. 
Tra questi scenari, viene verificato che il gestore delle comunicazioni possa essere inizializzato e finalizzato correttamente, senza incorrere in errori. 
Questa verifica è cruciale poiché assicura che tutte le operazioni di setup e di chiusura del protocollo siano eseguite correttamente, garantendo uno 
stato coerente del sistema sia prima che dopo l'esecuzione.

Un altro aspetto fondamentale della valutazione consiste nell'esaminare come il progetto gestisca correttamente gli errori in situazioni critiche. 
In particolare, vengono analizzati i comportamenti del protocollo quando si tenta di scrivere su un canale non registrato e quando si tenta di leggere 
da un canale non registrato. È essenziale che il protocollo sia in grado di identificare e segnalare tali errori con precisione, fornendo messaggi di 
errore comprensibili che facilitino la risoluzione dei problemi.

Inoltre, i test includono scenari che simulano la comunicazione effettiva tra due entità registrate correttamente. Questi scenari 
permettono di verificare il flusso completo della comunicazione, dall'inizializzazione alla trasmissione e ricezione dei messaggi, 
fino alla finalizzazione del protocollo. Questa verifica è particolarmente importante poiché dimostra l'efficacia del protocollo nella gestione della comunicazione 
tra le entità coinvolte e permette di controllare che il progetto funzioni correttamente senza generare errori inattesi.

Questi scenari, inclusi nei test, sono progettati per garantire che il protocollo \ac{MQTT} implementato risponda in modo affidabile e robusto in una varietà di situazioni, 
sia in condizioni ideali di funzionamento che in presenza di errori o situazioni impreviste. L'obiettivo è assicurare che il protocollo mantenga prestazioni elevate e affidabili, 
indipendentemente dalle circostanze operative. Il risultato atteso è che il sistema risponda adeguatamente alle esigenze di comunicazione e gestione degli errori, 
offrendo una soluzione solida e stabile per l'uso previsto.

\section{Tecnologie Utilizzate}

\subsection{Kotest}
Kotest offre un framework di testing multipiattaforma specificamente progettato per Kotlin. Kotest oltre a semplificare il processo di scrittura e di esecuzione dei test, 
si distingue per la sua flessibilità e le funzionalità avanzate. Grazie al supporto per test di proprietà, test parametrizzati e altre caratteristiche, Kotest garantisce prestazioni 
eccellenti e affidabilità nei risultati, fornendo un solido fondamento per la verifica e la convalida del codice Kotlin.

Kotest permette anche la creazione di test personalizzati, che possono essere configurati in modo dettagliato per adattarsi alle specifiche esigenze del progetto. 
La possibilità di eseguire test in parallelo contribuisce a ridurre significativamente i tempi di esecuzione, migliorando l'efficienza complessiva del ciclo di sviluppo. 
Inoltre, la compatibilità di Kotest con diversi ambienti di integrazione continua (\ac{CI/CD}) ne facilita l'adozione in progetti di qualsiasi dimensione e complessità.

\subsection{Arrow}
Arrow è una libreria potente che porta la programmazione funzionale idiomatica in Kotlin, arricchendo il linguaggio con concetti come i tipi di dati immutabili e le monadi. 
L'integrazione di Arrow nel progetto migliora significativamente la qualità del codice, facilitandone la manutenzione e rendendolo più leggibile e testabile. 
Questa libreria contribuisce in modo tangibile alla costruzione di applicazioni Kotlin più robuste e manutenibili.

Arrow offre una vasta gamma di funzionalità, tra cui i data types per rappresentare strutture di dati comuni in modo sicuro e idiomatico, e le typeclasses che consentono di estendere 
le funzionalità del linguaggio in maniera modulare. La presenza di effetti gestiti (Managed Effects) permette di scrivere codice che gestisce side effects in modo controllato e 
prevedibile, riducendo i rischi associati a operazioni come l'accesso al network o al filesystem. L'utilizzo di Arrow facilita inoltre l'adozione di pattern di programmazione 
funzionale come le funzioni pure e le composizioni, migliorando la coesione e la riusabilità del codice.

\subsection{Kmqtt}
Kmqtt riveste un ruolo cruciale nell'implementazione della comunicazione tramite \ac{MQTT} nel progetto. Questa libreria, progettata per Kotlin Multiplatform, offre 
un'implementazione unificata di \ac{MQTT} su tutte le piattaforme di interesse al progetto, In particolare per \ac{JVM} e native. La sua facilità d'uso e la flessibilità consentono di integrare la comunicazione 
\ac{MQTT} in modo uniforme e affidabile su tutte le piattaforme supportate, fornendo una solida base per lo sviluppo delle funzionalità di comunicazione nell'applicazione.

\subsection{MQTT.js}
MQTT.js è una libreria per lo sviluppo di applicazioni web che richiedono comunicazione \ac{MQTT} in ambienti JavaScript. 
MQTT.js è progettata per essere leggera, altamente performante e sempliceda usare, consentendo di gestire un elevato numero di messaggi con una latenza minima. 
La libreria supporta tutti i principali meccanismi di sicurezza, inclusa la crittografia SSL/TLS e l'autenticazione basata su username e password, garantendo una comunicazione 
sicura anche in contesti sensibili.

\subsection{Mosquitto}

Mosquitto rappresenta il cuore dell'infrastruttura \ac{MQTT} del progetto, offrendo un broker \ac{MQTT} open source che supporta sia l'hosting locale che il servizio pubblico. 
La leggerezza e la configurabilità di Mosquitto lo rendono una scelta ideale per creare un ambiente di sviluppo e testing robusto per le applicazioni basate su \ac{MQTT}. 
Le sue funzionalità avanzate, come l'autenticazione e la sicurezza delle connessioni, garantiscono un'esperienza di sviluppo sicura e affidabile.

\subsection{Git}
Git svolge un ruolo fondamentale nel controllo di versione del codice sorgente del progetto. Questo sistema di controllo di versione distribuito consente agli sviluppatori 
di tracciare le modifiche al codice, collaborare in modo efficiente con altri membri del team e gestire diverse versioni del progetto. La sua flessibilità e la vasta gamma 
di funzionalità supportate lo rendono una scelta versatile per il controllo di versione in progetti di qualsiasi dimensione e complessità.

Git offre strumenti potenti per la gestione delle branch, permettendo agli sviluppatori di lavorare su nuove funzionalità o bug fix in isolamento, prima di integrare 
le modifiche nel branch principale. Il sistema di merging di Git è sofisticato e permette di risolvere conflitti in maniera efficace. La presenza di piattaforme come GitHub 
ha ulteriormente esteso le capacità di Git, fornendo strumenti per la revisione del codice, l'integrazione continua e la gestione dei progetti, facilitando una collaborazione 
più strutturata e produttiva.

\subsection{Gradle}

Gradle rappresenta il cuore del processo di build e automazione del progetto. Questo sistema di automazione della compilazione, con la sua configurabilità ed estendibilità, 
semplifica la gestione delle dipendenze, la compilazione del codice e l'esecuzione dei test. Grazie alla sua integrazione con Kotlin, Gradle contribuisce in modo significativo 
a rendere il processo di sviluppo più efficiente e organizzato, offrendo un ambiente di sviluppo ottimizzato e scalabile.

\subsection{Detekt}
Detekt è uno strumento di analisi statica del codice progettato specificamente per Kotlin, che aiuta a identificare problemi di qualità del codice e potenziali bug. 
Integrando Detekt nel progetto, è possibile eseguire una scansione automatica del codice sorgente per rilevare problemi di stile, errori comuni e complessità del codice.
Detekt offre una vasta gamma di regole predefinite che coprono vari aspetti della qualità del codice, come la complessità ciclomatica, le convenzioni di codice, i potenziali 
bug e le vulnerabilità di sicurezza. Inoltre, è possibile configurare Detekt per adattarsi alle esigenze specifiche del progetto, personalizzando le regole esistenti o creando 
nuove regole personalizzate.
L'uso di Detekt contribuisce a mantenere il codice pulito e manutenibile, facilitando la conformità agli standard di codifica e riducendo il rischio di errori. 
Detekt può essere integrato nei processi di integrazione continua (\ac{CI/CD}) per garantire che il codice nuovo o modificato venga analizzato automaticamente, fornendo feedback 
immediato agli sviluppatori e mantenendo alta la qualità del codice durante tutto il ciclo di sviluppo.


\chapter{Implementazione e Validazione}\label{chap:Implementazione e Validazione}

\section{Sviluppo}

\section{Validazione}

\section{Prestazione sulle diverse piattaforme}

\section{Integrazione in PulvReAKt}

\chapter{Conclusioni}\label{chap:Conclusioni}

%----------------------------------------------------------------------------------------
% BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\backmatter

\nocite{*} % Remove this as soon as you have the first citation

\bibliographystyle{alpha}
\bibliography{bibliography}

\begin{acknowledgements} % this is optional
Optional. Max 1 page.
\end{acknowledgements}

\end{document}
